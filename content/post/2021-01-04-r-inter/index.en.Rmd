---
title: 【R语言编程指南】R的内部机制
author: wutao
date: '2021-01-04'
slug: r-inter
categories:
  - R
tags:
  - notes
image: "77_cover_m.jpg"
---

Last compiled on `r format(Sys.time(), '%d %B, %Y')`

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE)
```

本章主要是学习四个方面：

- 惰性求值
- 复制修改机制
- 词法作用域
- 环境

## 惰性求值

惰性求值指的是：在函数调用时，参数的值只在用到的时侯才会被调用/执行

比如下面这个函数：

```{r example1,error=TRUE}
test0 <- function(x,y){
  if(x > 0){
    x
  }else{
    y
  }
}

test0(1,stop("Stop nrow"))
test0(-1,stop("Stop nrow"))
```
可以看到当调用`test0(1,stop("Stop nrow"))`并不会报错，因为这种情况下函数不会运行y(因为不需要y的值)；而在调用`test0(-1,stop("Stop nrow"))`的时候会发生报错是因为输入x是负数，因此会进入`else`运行y，而y的值是表达式`stop("Stop nrow")`所以会报错

在这一节中还有一个巧妙的用法:使用`stop`和`switch`来控制函数的输入:

```{r stop_switch,error=TRUE}
check_input <- function(x){
  switch(x,
         y = message("yes"),
         n = message("no"),
         stop("Invalid input")
  )
}

check_input("y")
check_input("n")
check_input("a")
```

## 复制——修改机制

复制修改机制指的是：当有多个变量指向同一个对象，那么修改一个变量(包括值和属性)就会生成该对象的一个副本

我们可以看一个例子：

```{r ex1}
x1 <- c(1,2,3)
x2 <- x1

##使用tracemem可以追踪变量的内存地址
tracemem(x1)
tracemem(x2)

x1[1] <- 0
```

可以看到在赋值操作中变量所指向的内存地址是一样的，但是在改变其中一个变量的值的时候，该变量的内存地址发生了变化，也就是说修改操作会生成一个副本，然后在该副本上进行修改

对于函数的参数也是这样，当我们传一个变量给函数的参数时，就相当于该变量和函数参数所表示的变量都指向我们传入的数据，所以在函数内部进行修改时并不会修改传入的变量，而是将该变量的值复制后再进行修改:

```{r ex2}
modify <- function(x){
  x[1] <- 2
  x
}

v1 <- c(1,2,3)
modify(v1)
v1
```

## 词法作用域

本节中有几个知识点：

1. 函数只有在被调用的时候才寻找变量：

```{r ex3,error=TRUE}
##定义函数
fun1 <- function(x){
  c(a,x,b)
}
#现在并没有定义a和b,但是创建函数时不会报错

fun1(1)
##由于调用函数时找不到相应的变量所以报错

a <- b <- 1
fun1(1)
```

2. 当函数被调用时，先会在函数内部搜索变量，如果在内部找不到相应的变量，就会在自己被定义的地方(所在的域或者环境)而不是被调用的地方搜索相应的变量----**词法作用域** 

```{r ex4,error=TRUE}
f1 <- function(x){
  x + p 
}

g1 <- function(x){
  p <- 1 
  f1(x)
}

g1(0)
##在g1内部调用f1，f1先在其内部找p，找不到；接着f1到其被定义的域/环境中找p，也找不到(因为p是在g1内部被定义的)，所以会报错

p <- 1
g1(0)
##在g1内部调用f1，f1先在其内部找p，找不到；接着f1到其被定义的域/环境中找p,这时就可以找到了
```

接下来看一个有意思的例子：

```{r ex5}
f1 <- function(x){
  p <- 1
  q <- 2
  cat(sprintf("1. [f1] p: %d, q: %d\n",p,q))
  f2 <- function(x){
    p <- 3
    cat(sprintf("2. [f2] p: %d, q: %d\n",p,q))
    c(x=x, p=p, q=q)
  }
  cat(sprintf("3. [f1] p: %d, q: %d",p,q))
  f2(x)
}

f1(0)

##注意运行的顺序和展示的值
```



## 环境的工作方式

