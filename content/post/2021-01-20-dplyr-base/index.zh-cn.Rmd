---
title: dplyr基础
author: wutao
date: '2021-01-20'
slug: dplyr_base
categories:
  - R
  - reading notes
tags:
  - R
image : "dplyr.png"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE,comment=">>")
```

参考：[dplyr base](https://github.com/tidyverse/dplyr/blob/master/vignettes/base.Rmd)

这篇文章主要比较dplyr函数和base R的区别

## Overview

1. dplyr动词输入和输出都是数据框，而base R大部分是单独的向量 \       
2. dplyr依赖非标准计算，所以不需要$来选择变量(列)
3. dplyr使用一系列具有单个目的的动词，而在baseR中通常使用[]
4. dplyr的动词通常可以通过管道(%>%)连在一起，而baseR中常常需要将中间结果保存为变量
5. 所有的dplyr动词都可以处理分组数据并且和处理整个数据框类似，但是在baseR中可能每个组的处理都有着不同的形式

## One table verbs

| dplyr                         | base                                             |
|-------------------------------|--------------------------------------------------|
| `arrange(df, x)`              | `df[order(x), , drop = FALSE]`                   | 
| `distinct(df, x)`             | `df[!duplicated(x), , drop = FALSE]`, `unique()` | 
| `filter(df, x)`               | `df[which(x), , drop = FALSE]`, `subset()`       | 
| `mutate(df, z = x + y)`       | `df$z <- df$x + df$y`, `transform()`             | 
| `pull(df, 1)`                 | `df[[1]]`                                        | 
| `pull(df, x)`                 | `df$x`                                           | 
| `rename(df, y = x)`           | `names(df)[names(df) == "x"] <- "y"`             | 
| `relocate(df, y)`             | `df[union("y", names(df))]`                       | 
| `select(df, x, y)`            | `df[c("x", "y")]`, `subset()`                    | 
| `select(df, starts_with("x")` | `df[grepl(names(df), "^x")]`                     | 
| `summarise(df, mean(x))`      | `mean(df$x)`, `tapply()`, `aggregate()`, `by()`  | 
| `slice(df, c(1, 2, 5))`       | `df[c(1, 2, 5), , drop = FALSE]`                 | 

首先载入示例数据：
```{r ex1}
library(dplyr)

mtcars <- as_tibble(mtcars)
iris <- as_tibble(iris)

```

### `arrange()` 通过变量来组织行

`dplyr::arrange()`通过一列或多列的值来对数据框的行进行排序：
```{r ex2}
mtcars %>% arrange(cyl,disp)

```

`desc()`辅助函数可以进行降序排序：
```{r ex3}
mtcars %>% arrange(desc(cyl),desc(disp))

```

在base R中可以使用[+order函数对行进行排序：
```{r ex4}
mtcars[order(mtcars$cyl,mtcars$disp),,drop= FALSE]

```
记得加上drop= FALSE，不然如果输入是只有一列的数据框，输出就是一个向量而不是数据框了：
```{r ex5}
mtcars1 <- mtcars %>% select(mpg)
a <- mtcars1[order(mtcars1$mpg),]
a
```

